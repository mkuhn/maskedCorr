# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate correlation only for ranges where the mask bit has been set
#'
#' @param v1 Input vector 1
#' @param v2 Input vector 2
#' @param mask Mask, each bit that is set will be included in the correlation
#' @param mask_ranges List of start, end tuples for each of the mask groups
#' @return The Pearson correlation between the designated parts of the input vectors
#' @export
masked_corr <- function(v1, v2, mask, mask_ranges) {
    .Call('maskedCorr_masked_corr', PACKAGE = 'maskedCorr', v1, v2, mask, mask_ranges)
}

#' Test if any bit in the input masks is set exactly once
contains_singleton <- function(vs, N_bits) {
    .Call('maskedCorr_contains_singleton', PACKAGE = 'maskedCorr', vs, N_bits)
}

#' count the number of bits set
#' @export
count_set_bits <- function(vs) {
    .Call('maskedCorr_count_set_bits', PACKAGE = 'maskedCorr', vs)
}

#' Convert the mask to an integer for easier handling with dplyr
#' NOTE! We have at most 6 elements in the mask, and 4 bits = 24 bits.
#' so we're safe.
#' @param masks Integer vector of masks
#' @param bits_per_mask Number of bits in each mask
#' @export
masks_to_int <- function(masks, bits_per_mask) {
    .Call('maskedCorr_masks_to_int', PACKAGE = 'maskedCorr', masks, bits_per_mask)
}

#' Split from integer value into masks
#' @param int_masks encoded masks
#' @param bits_per_mask Number of bits in each mask
#' @param N_masks Number of masks
#' @export
int_to_masks <- function(int_masks, bits_per_mask, N_masks) {
    .Call('maskedCorr_int_to_masks', PACKAGE = 'maskedCorr', int_masks, bits_per_mask, N_masks)
}

#' Cycle through all possible mask combinations by incrementing the mask
#'
#' @param mask Input mask
#' @param N threshold for setting one part of the mask to zero and moving to next
#' @param skip_singletons If set, do not return singletons
#' @param skip_zeros If set, do not return masks where any submask is 0
#' @return The incremented mask, or \code{NA} if all combinations have been reached
increment_mask <- function(mask, N_bits, skip_singletons, skip_zeros) {
    .Call('maskedCorr_increment_mask', PACKAGE = 'maskedCorr', mask, N_bits, skip_singletons, skip_zeros)
}

#' Generate vector of masks containing all intersections of bits
#' @param masks input set of masks
#' @return same as upper.tri of outer(masks, masks), bitwAnd)
masks_to_target <- function(masks) {
    .Call('maskedCorr_masks_to_target', PACKAGE = 'maskedCorr', masks)
}

